name: Deploy to AWS

on:
  push:
    branches: [Feateure-aws-deploy]
  workflow_dispatch:  # Allow manual triggers

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: skytrack-backend
  EC2_HOST: ${{ secrets.EC2_HOST }}
  EC2_USER: ${{ secrets.EC2_USER }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/Feateure-aws-deploy'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get secrets from AWS Secrets Manager
        id: get-secrets
        run: |
          # Get MongoDB connection string
          MONGO_SECRET=$(aws secretsmanager get-secret-value \
            --secret-id "mongo" \
            --query SecretString --output text)

          # Get database credentials if using PostgreSQL
          DB_SECRET=$(aws secretsmanager get-secret-value \
            --secret-id "postgres" \
            --query SecretString --output text)

          # Parse and export secrets (they should be JSON format)
          echo "DATABASE_URL=$(echo $DB_SECRET | jq -r '.DATABASE_URL')" >> $GITHUB_ENV
          echo "MONGO_CONNECTION_STRING=$(echo $MONGO_SECRET | jq -r '.connectionString')" >> $GITHUB_ENV
          echo "MONGO_DATABASE=$(echo $MONGO_SECRET | jq -r '.database')" >> $GITHUB_ENV

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build Docker image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .

          # Push to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Deploy to EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$EC2_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts

          # SSH into EC2 and run deployment commands
          ssh -i ~/.ssh/id_rsa "$EC2_USER@$EC2_HOST" "
            export AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}'
            export AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}'
            export AWS_SESSION_TOKEN='${{ secrets.AWS_SESSION_TOKEN }}'
            set -e # Exit script on any error

            echo 'Logging into AWS ECR...'
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY

            echo 'Pulling the latest Docker image...'
            docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

            echo 'Stopping and removing old container...'
            docker stop skytrack-backend || true
            docker rm skytrack-backend || true

            echo 'Starting new container with environment variables...'
            docker run -d \
              --name skytrack-backend \
              --restart unless-stopped \
              -p 3000:3000 \
              -e DATABASE_URL='${{ env.DATABASE_URL }}' \
              -e MONGO_CONNECTION_STRING='${{ env.MONGO_CONNECTION_STRING }}' \
              -e MONGO_DATABASE='${{ env.MONGO_DATABASE }}' \
              -e NODE_ENV=production \
              -e PORT=3000 \
              $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

            echo 'Running database migrations...'
            docker exec skytrack-backend npm run db:deploy || echo 'Migration failed or not needed'

            echo 'Cleaning up old images...'
            docker image prune -f

            echo '‚úÖ Deployment completed successfully!'
          "

      - name: Verify deployment
        run: |
          # Wait for service to be ready
          sleep 45

          # Check if service is responding (NestJS serves health at /api/health)
          if curl -f http://$EC2_HOST:3000/api/health; then
            echo "‚úÖ Service is healthy and responding"
          else
            echo "‚ùå Service health check failed"
            exit 1
          fi

      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "üöÄ Deployment to test environment completed successfully!"
            echo "üåê Application available at: http://$EC2_HOST:3000"
            echo "üìö API Documentation: http://$EC2_HOST:3000/api-docs"
          else
            echo "‚ùå Deployment to test environment failed"
          fi